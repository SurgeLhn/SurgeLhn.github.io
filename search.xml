<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>并查集解决小岛问题</title>
    <url>/2021/02/19/UnionFind/UnionFindIsland/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本篇文章主要解决LeetCode小岛问题，使用方法为并查集。</p>
<h2 id="LeetCode695-岛屿的最大面积"><a href="#LeetCode695-岛屿的最大面积" class="headerlink" title="LeetCode695 岛屿的最大面积"></a>LeetCode695 岛屿的最大面积</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://gitee.com/liang_haonan/blogimg/raw/master/img/maxArea.PNG"></p>
<p><a href="https://leetcode-cn.com/problems/max-area-of-island/"><em>点此链接跳转题目</em></a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题就得考虑并查集中<code>rank[i]</code>的用法。<strong>并查集中<code>rank[i]</code>表示以编号<code>i</code>的点作为根节点的树的结点数量</strong>。这么说好像很绕，那么可以粗略地当作是连接的编号<code>i</code>所连接的结点的数量。<br>那么这道题就只要找到最大的<code>rank[i]</code>就行了。</p>
<p>那么就把模板稍微改一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">    <span class="comment">//最大连通分量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line">    <span class="comment">//x连接的结点为parent[x]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">//对应的根结点的连通分量的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始为1</span></span><br><span class="line">        max=<span class="number">1</span>;</span><br><span class="line">        parent=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">            rank[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*找寻x的根节点*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x!=parent[x])</span><br><span class="line">            x=parent[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*检查p和q是否连接*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*将p和q连接在一起*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP=find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ=find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP==rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[rootP]&lt;rank[rootQ])&#123;</span><br><span class="line">            parent[rootP]=rootQ;</span><br><span class="line">            rank[rootQ]+=rank[rootP];</span><br><span class="line">            max=Math.max(rank[rootQ],max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootQ]=rootP;</span><br><span class="line">            rank[rootP]+=rank[rootQ];</span><br><span class="line">            max=Math.max(rank[rootP],max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*最大的rank[i]*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下的编号与连接就按照二维数组中使用并查集的方法来进行。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>这里要注意，<strong>因为<code>rank[i]</code>最小值都为1，所以还要判断数组中有没有1，如果没有1的话直接返回0</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">    <span class="comment">//最大连通分量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line">    <span class="comment">//x连接的结点为parent[x]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">//对应的根结点的连通分量的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        max=<span class="number">1</span>;</span><br><span class="line">        parent=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">            rank[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*找寻x的根节点*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x!=parent[x])</span><br><span class="line">            x=parent[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*检查p和q是否连接*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*将p和q连接在一起*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP=find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ=find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP==rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[rootP]&lt;rank[rootQ])&#123;</span><br><span class="line">            parent[rootP]=rootQ;</span><br><span class="line">            rank[rootQ]+=rank[rootP];</span><br><span class="line">            max=Math.max(rank[rootQ],max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootQ]=rootP;</span><br><span class="line">            rank[rootP]+=rank[rootQ];</span><br><span class="line">            max=Math.max(rank[rootP],max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.length==<span class="number">0</span>||grid[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断是否有1</span></span><br><span class="line">        <span class="keyword">boolean</span> hasOne=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m=grid.length;</span><br><span class="line">        <span class="keyword">int</span> n=grid[<span class="number">0</span>].length;</span><br><span class="line">        UnionFind uf=<span class="keyword">new</span> UnionFind(m*n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    hasOne=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> idx=i*n+j;</span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>&lt;m&amp;&amp;grid[i+<span class="number">1</span>][j]==<span class="number">1</span>)  uf.union(idx,idx+n);</span><br><span class="line">                    <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n&amp;&amp;grid[i][j+<span class="number">1</span>]==<span class="number">1</span>)  uf.union(idx,idx+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果全是0就返回0</span></span><br><span class="line">        <span class="keyword">return</span> hasOne?uf.getMax():<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode305-岛屿数量II"><a href="#LeetCode305-岛屿数量II" class="headerlink" title="LeetCode305 岛屿数量II"></a>LeetCode305 岛屿数量II</h3><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://gitee.com/liang_haonan/blogimg/raw/master/img/islandNum.PNG"><br><img src="https://gitee.com/liang_haonan/blogimg/raw/master/img/islandNum2.PNG"></p>
<p><a href="https://leetcode-cn.com/problems/number-of-islands-ii/"><em>点此链接跳转题目</em></a></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题相对于岛屿数量I，不同的部分就是<strong>一步步填海，然后在判断数量</strong>。所以难度就是<strong>填完海了以后数量怎么变化</strong>。</p>
<h4 id="初始设置"><a href="#初始设置" class="headerlink" title="初始设置"></a>初始设置</h4><p>第一步填海，不管填在哪里，都只有一座岛。所以根以往并查集模型不同，<code>count</code>初始值为1。<br>即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    count=<span class="number">1</span>;</span><br><span class="line">    parent=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    rank=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        parent[i]=i;</span><br><span class="line">        rank[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="填海过程"><a href="#填海过程" class="headerlink" title="填海过程"></a>填海过程</h4><p>那么，抽象出一个填海的模型，计数的过程可以如下图所示。<br><img src="https://gitee.com/liang_haonan/blogimg/raw/master/img/island2.png"></p>
<p>根据上述过程总结一下：</p>
<ol>
<li>填完一个位置以后，<strong>数量首先+1</strong>。</li>
<li>观察四个方向是否有岛屿，且是否连接，如果<strong>其中一个方向有已经填过的岛屿，且没有连接在一起，将填海位置与已经填过的岛屿连接在一起，且数量-1</strong>。</li>
</ol>
<p>首先为了完成过程1，得单独设置<code>add</code>函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后为了完成过程2，还要把<code>union</code>的函数修改以下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*将p和q连接在一起*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP=find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ=find(q);</span><br><span class="line">    <span class="keyword">if</span>(rootP==rootQ)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(rank[rootP]&lt;rank[rootQ])&#123;</span><br><span class="line">        parent[rootP]=rootQ;</span><br><span class="line">        rank[rootQ]+=rank[rootP];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        parent[rootQ]=rootP;</span><br><span class="line">        rank[rootP]+=rank[rootQ];</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="题目模型"><a href="#题目模型" class="headerlink" title="题目模型"></a>题目模型</h4><p>按照上述过程修改之后的并查集模型如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">    <span class="comment">//连通分量的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//x连接的结点为parent[x]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">//对应的根结点的连通分量的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        count=<span class="number">1</span>;</span><br><span class="line">        parent=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">            rank[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*找寻x的根节点*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x!=parent[x])</span><br><span class="line">            x=parent[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*检查p和q是否连接*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*将p和q连接在一起*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP=find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ=find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP==rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[rootP]&lt;rank[rootQ])&#123;</span><br><span class="line">            parent[rootP]=rootQ;</span><br><span class="line">            rank[rootQ]+=rank[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootQ]=rootP;</span><br><span class="line">            rank[rootP]+=rank[rootQ];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*返回连通分量的个数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*添加岛屿*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>由于本题目没有像岛屿数量1设置地图的二维数组，<strong>所以为了得到填海的周围是否有岛屿，可以采用<code>boolean[] isLand</code>数组</strong>。对于位置<code>(i,j)</code>，如果要填海，则<code>isLand[i*n+j]=true</code>。同时，这个题目用例还缺心眼，会在列表中出现重复的位置，<strong>所以如果已经填过了，那么就不要再操作了</strong>。<br>编号则按照二维数组的方式进行编号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">    <span class="comment">//连通分量的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//x连接的结点为parent[x]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">//对应的根结点的连通分量的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        count=<span class="number">1</span>;</span><br><span class="line">        parent=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">            rank[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*找寻x的根节点*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x!=parent[x])</span><br><span class="line">            x=parent[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*检查p和q是否连接*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*将p和q连接在一起*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP=find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ=find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP==rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[rootP]&lt;rank[rootQ])&#123;</span><br><span class="line">            parent[rootP]=rootQ;</span><br><span class="line">            rank[rootQ]+=rank[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootQ]=rootP;</span><br><span class="line">            rank[rootP]+=rank[rootQ];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*返回连通分量的个数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*添加岛屿*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">numIslands2</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span>[][] positions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] isLand=<span class="keyword">new</span> <span class="keyword">boolean</span>[m*n];</span><br><span class="line">        UnionFind uf=<span class="keyword">new</span> UnionFind(m*n);</span><br><span class="line">        List&lt;Integer&gt;res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] p:positions)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=p[<span class="number">0</span>],y=p[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> idx=x*n+y;</span><br><span class="line">            <span class="comment">//已经添加过了</span></span><br><span class="line">            <span class="keyword">if</span>(!isLand[idx])&#123;</span><br><span class="line">                isLand[idx]=<span class="keyword">true</span>;</span><br><span class="line">                uf.add(idx);</span><br><span class="line">                <span class="comment">//检查四周</span></span><br><span class="line">                <span class="keyword">if</span>(x-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;isLand[idx-n])   uf.union(idx,idx-n);</span><br><span class="line">                <span class="keyword">if</span>(x+<span class="number">1</span>&lt; m&amp;&amp;isLand[idx+n])   uf.union(idx,idx+n);</span><br><span class="line">                <span class="keyword">if</span>(y-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;isLand[idx-<span class="number">1</span>])   uf.union(idx,idx-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(y+<span class="number">1</span>&lt; n&amp;&amp;isLand[idx+<span class="number">1</span>])   uf.union(idx,idx+<span class="number">1</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            res.add(uf.getCount());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LeetCode-827最大人工岛"><a href="#LeetCode-827最大人工岛" class="headerlink" title="LeetCode 827最大人工岛"></a>LeetCode 827最大人工岛</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://gitee.com/liang_haonan/blogimg/raw/master/img/maxArtificial.PNG"></p>
<p><a href="https://leetcode-cn.com/problems/making-a-large-island/"><em>点此链接跳转题目</em></a></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这道题像上面两个模型叠加。首先当然是按照地图进行填海。</p>
<p>然后考虑该填那个位置能够得到最大的人工岛，<strong>范围嘛，当然是每个是值为0的位置</strong>。</p>
<p>如果填了以后，看看四个方向是否有岛，如果周围有岛，且没有连接，那么连接以后可以得到多大的面积。如果连接了就不必考虑了，所以为了防止重复计算，**要使用Set来存储周围岛屿的根节点的值(find函数)**。举个例子：如果你无聊，打算统计一下啊你周围人的家庭财产的总合，如果遇到两个人是一家人，他们告诉你相同的数量，但是你不会重复计算的，对不对？因为你知道如果是一家人，那么只有一份家庭财产。</p>
<p><strong>然后根据根节点得到对应的面积(rank)进行相加，再加1就可以得到该位置填海的岛屿的面积</strong>。</p>
<p>即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UnionFind uf=<span class="keyword">new</span> UnionFind(m*n);</span><br><span class="line"><span class="comment">//先把原来的岛屿构造好</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> idx=i*n+j;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;m&amp;&amp;grid[i+<span class="number">1</span>][j]==<span class="number">1</span>)  uf.union(idx,idx+n);</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n&amp;&amp;grid[i][j+<span class="number">1</span>]==<span class="number">1</span>)  uf.union(idx,idx+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始填海</span></span><br><span class="line"><span class="keyword">int</span> newMax=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> idx=i*n+j;</span><br><span class="line">            Set&lt;Integer&gt;set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[i-<span class="number">1</span>][j]==<span class="number">1</span>) set.add(uf.find(idx-n));</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt; m&amp;&amp;grid[i+<span class="number">1</span>][j]==<span class="number">1</span>) set.add(uf.find(idx+n));</span><br><span class="line">            <span class="keyword">if</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[i][j-<span class="number">1</span>]==<span class="number">1</span>) set.add(uf.find(idx-<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>&lt; n&amp;&amp;grid[i][j+<span class="number">1</span>]==<span class="number">1</span>) set.add(uf.find(idx+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">int</span> area=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(Integer id:set)&#123;</span><br><span class="line">                area+=uf.size(id);</span><br><span class="line">            &#125;</span><br><span class="line">            newMax=Math.max(newMax,area);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>这题还是有陷进滴，比如说示例3，如果填不了海，那么按照上面代码填海的面积就为0，所以还要根没有填海的最大岛屿面积来比较取最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">    <span class="comment">//x连接的结点为parent[x]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">//对应的根结点的连通分量的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line">    <span class="comment">//最大连通分量的结点数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        max=<span class="number">1</span>;</span><br><span class="line">        parent=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">            rank[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*找寻x的根节点*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x!=parent[x])</span><br><span class="line">            x=parent[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*检查p和q是否连接*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*将p和q连接在一起*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP=find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ=find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP==rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[rootP]&lt;rank[rootQ])&#123;</span><br><span class="line">            parent[rootP]=rootQ;</span><br><span class="line">            rank[rootQ]+=rank[rootP];</span><br><span class="line">            max=Math.max(max,rank[rootQ]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootQ]=rootP;</span><br><span class="line">            rank[rootP]+=rank[rootQ];</span><br><span class="line">            max=Math.max(max,rank[rootP]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*最大连通分量的个数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*返回岛屿的面积*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rank[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=grid.length;</span><br><span class="line">        <span class="keyword">int</span> n=grid[<span class="number">0</span>].length;</span><br><span class="line">        UnionFind uf=<span class="keyword">new</span> UnionFind(m*n);</span><br><span class="line">        <span class="comment">//先把原来的岛屿构造好</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> idx=i*n+j;</span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>&lt;m&amp;&amp;grid[i+<span class="number">1</span>][j]==<span class="number">1</span>)  uf.union(idx,idx+n);</span><br><span class="line">                    <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n&amp;&amp;grid[i][j+<span class="number">1</span>]==<span class="number">1</span>)  uf.union(idx,idx+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> originMax=uf.getMax();</span><br><span class="line">        <span class="comment">//开始填海</span></span><br><span class="line">        <span class="keyword">int</span> newMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> idx=i*n+j;</span><br><span class="line">                    Set&lt;Integer&gt;set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                    <span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[i-<span class="number">1</span>][j]==<span class="number">1</span>) set.add(uf.find(idx-n));</span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>&lt; m&amp;&amp;grid[i+<span class="number">1</span>][j]==<span class="number">1</span>) set.add(uf.find(idx+n));</span><br><span class="line">                    <span class="keyword">if</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[i][j-<span class="number">1</span>]==<span class="number">1</span>) set.add(uf.find(idx-<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span>(j+<span class="number">1</span>&lt; n&amp;&amp;grid[i][j+<span class="number">1</span>]==<span class="number">1</span>) set.add(uf.find(idx+<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">int</span> area=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(Integer id:set)&#123;</span><br><span class="line">                        area+=uf.size(id);</span><br><span class="line">                    &#125;</span><br><span class="line">                    newMax=Math.max(newMax,area);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(newMax,originMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面几道题都对并查集进行小小的改动，所以不仅要将模型记住，同时还要理解，这样才可以套用模型解决更多问题。</p>
]]></content>
      <categories>
        <category>UnionFind</category>
      </categories>
      <tags>
        <tag>UnionFind</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集基本使用</title>
    <url>/2021/02/18/UnionFind/UnionFindBasis/</url>
    <content><![CDATA[<p><img src="https://gitee.com/liang_haonan/blogimg/raw/master/img/R68e84244fb284d6a2f38adb46d975426.jpg"></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>对于以下的题目，便是并查集模板的基本用法。</p>
<h2 id="Leetcode547-省份数量"><a href="#Leetcode547-省份数量" class="headerlink" title="Leetcode547.省份数量"></a>Leetcode547.省份数量</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://gitee.com/liang_haonan/blogimg/raw/master/img/ufb1.PNG"></p>
<p><a href="https://leetcode-cn.com/problems/number-of-provinces/"><em>点此链接跳转题目</em></a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接套模板，然后得出连通分量的数量即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">  <span class="comment">//记录连通分量的个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">  <span class="comment">//节点x指向的节点是parent[x]</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[]parent;</span><br><span class="line">  <span class="comment">/*构造函数，最开始每个节点指向自己*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count=n;</span><br><span class="line">    parent=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">      parent[i]=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*将节点p与q连接*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(connect(p,q))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> rootP=find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ=find(q);</span><br><span class="line">    parent[rootP]=rootQ;</span><br><span class="line">    count--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*找到x的根节点*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(parent[x]!=x)</span><br><span class="line">      x=parent[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*查看p与q是否连接*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP=find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ=find(q);</span><br><span class="line">    <span class="keyword">return</span> rootP==rootQ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*查看连通分量的个数*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">number</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> N=M.length;</span><br><span class="line">      UF uf=<span class="keyword">new</span> UF(N);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(M[i][j]==<span class="number">1</span>)</span><br><span class="line">            uf.union(i,j);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> uf.number();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode839-相似的字符串数组"><a href="#Leetcode839-相似的字符串数组" class="headerlink" title="Leetcode839.相似的字符串数组"></a>Leetcode839.相似的字符串数组</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://gitee.com/liang_haonan/blogimg/raw/master/img/ufb3.PNG"></p>
<p><a href="https://leetcode-cn.com/problems/similar-string-groups/"><em>点此链接跳转题目</em></a></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>跟上题一样，每个字符串可以看成一个点，若两个字符串相似便可以看成两个点连接，最后判断连通分量的个数即可。</p>
<p>判断相似的方法，由于是字母异位词(所有单词字母种类数量相同位置不同)，所以只要对应两个位置及以下字母不相同即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSimilar</span><span class="params">(String a,String b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n=a.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.charAt(i)!=b.charAt(i))</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt&lt;=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        count=n;</span><br><span class="line">        parent=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">            rank[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x!=parent[x])</span><br><span class="line">            x=parent[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP=find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ=find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP==rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[rootP]&lt;rank[rootQ])&#123;</span><br><span class="line">            parent[rootP]=rootQ;</span><br><span class="line">            rank[rootQ]+=rank[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootQ]=rootP;</span><br><span class="line">            rank[rootP]+=rank[rootQ];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSimilar</span><span class="params">(String a,String b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = a.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.charAt(i) != b.charAt(i)) cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=strs.length;</span><br><span class="line">        UnionFind uf=<span class="keyword">new</span> UnionFind(len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isSimilar(strs[i],strs[j]))</span><br><span class="line">                    uf.union(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode737-句子相似性II"><a href="#Leetcode737-句子相似性II" class="headerlink" title="Leetcode737.句子相似性II"></a>Leetcode737.句子相似性II</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://gitee.com/liang_haonan/blogimg/raw/master/img/ufb2.PNG"></p>
<p><a href="https://leetcode-cn.com/problems/sentence-similarity-ii/"><em>点此链接跳转题目</em></a></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>根据上面的题目一样，将每个字符串当作一个点，如果两个字符串相似那就将对应的点连接到一起。那么如何让每个字符串对应相应的点呢？当然是对<code>pairs</code>每个字符串进行编号。</p>
<p><strong>编号代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用hashMap使每个字符串有对应的编号</span></span><br><span class="line">Map&lt;String,Integer&gt;hashMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//从0开始编号</span></span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(List&lt;String&gt;pair:pairs)&#123;</span><br><span class="line">    String a=pair.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//如果已经有编号就放弃</span></span><br><span class="line">    <span class="keyword">if</span>(!hashMap.containsKey(a))&#123;</span><br><span class="line">        hashMap.put(a,index);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    String b=pair.get(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!hashMap.containsKey(b))&#123;</span><br><span class="line">        hashMap.put(b,index);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后只要看<code>words1</code>和<code>words2</code>对应位置的字符串是否相似，即对应位置字符串各自对应的编号是否在同一连通分量里面即可，如果有一个位置不在，那就直接<code>false</code>。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">int</span>[] rank;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        parent=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">            rank[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x!=parent[x])</span><br><span class="line">            x=parent[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP=find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ=find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP==rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[rootP]&lt;rank[rootQ])&#123;</span><br><span class="line">            parent[rootP]=rootQ;</span><br><span class="line">            rank[rootQ]+=rank[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootQ]=rootP;</span><br><span class="line">            rank[rootP]+=rank[rootQ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areSentencesSimilarTwo</span><span class="params">(String[] words1, String[] words2, List&lt;List&lt;String&gt;&gt; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words1.length!=words2.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map&lt;String,Integer&gt;hashMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt;pair:pairs)&#123;</span><br><span class="line">            String a=pair.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(!hashMap.containsKey(a))&#123;</span><br><span class="line">                hashMap.put(a,index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            String b=pair.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!hashMap.containsKey(b))&#123;</span><br><span class="line">                hashMap.put(b,index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        UnionFind unionfind=<span class="keyword">new</span> UnionFind(index);</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt;pair:pairs)&#123;</span><br><span class="line">            String a=pair.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> index0=hashMap.get(a);</span><br><span class="line">            String b=pair.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> index1=hashMap.get(b);</span><br><span class="line">            unionfind.union(index0,index1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len=words1.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            String word1=words1[i]; Integer index0=hashMap.get(word1);</span><br><span class="line">            String word2=words2[i]; Integer index1=hashMap.get(word2);</span><br><span class="line">            <span class="keyword">if</span>(word1.equals(word2))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(index0==<span class="keyword">null</span>||index1==<span class="keyword">null</span>||!unionfind.connected(index0,index1))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LeetCode200-岛屿数量"><a href="#LeetCode200-岛屿数量" class="headerlink" title="LeetCode200.岛屿数量"></a>LeetCode200.岛屿数量</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p><img src="https://gitee.com/liang_haonan/blogimg/raw/master/img/uf2.PNG"></p>
<p><a href="https://leetcode-cn.com/problems/number-of-islands/"><em>点此链接跳转题目</em></a></p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>这道题的背景是一个二维数组<code>grid</code>，那么<strong>就把每个<code>grid[i][j]</code>当作并查集要连接的点</strong>，则一共有<code>m*n</code>个点(其中<code>m=gird.length</code>，<code>n=grid[0].length</code>)。<br>即:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m=grid.length;</span><br><span class="line"><span class="keyword">int</span> n=grid[<span class="number">0</span>].length;</span><br><span class="line">UnionFind uf=<span class="keyword">new</span> UnionFind(m*n) </span><br></pre></td></tr></table></figure>
<p>然后就是解决<strong>编号</strong>和<strong>连接</strong>的问题。用如下图矩阵来举例子。</p>
<div align=center>
  <img src="https://gitee.com/liang_haonan/blogimg/raw/master/img/2ndArray2.png"/>
</div>

<h4 id="编号"><a href="#编号" class="headerlink" title="编号"></a>编号</h4><p>对于上述矩阵，可以有一种编号方式，如下：</p>
<div align=center>
  <img src="https://gitee.com/liang_haonan/blogimg/raw/master/img/2ndArray.png"/>
</div>

<p>即**点<code>(i,j)</code>的编号就为<code>i*n+j</code>(其中<code>m=gird.length</code>，<code>n=grid[0].length</code>)**。好了，编号问题就解决了。</p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>然后就是连接，按照题目要求，<strong>把值为1的点全部连接起来</strong>，<strong>每个点只能与水平相邻和数值相邻的点连接</strong>。<br>描述地更加具体就是:</p>
<ol>
<li>找到编号为<code>0</code>的点，让它与编号为<code>1</code>和编号为<code>3</code>的点连接起来。</li>
<li>找到编号为<code>1</code>的点，让它与编号为<code>0</code>和编号为<code>4</code>的点连接起来。</li>
<li>找到编号为<code>3</code>的点，让它与编号为<code>0</code>和编号为<code>4</code>的点连接起来。</li>
<li>找到编号为<code>4</code>的点，让它与编号为<code>1</code>和编号为<code>3</code>的点连接起来。</li>
</ol>
<p>虽然步骤是这样，但是还是上述过程可以看到有很多重复项，所以一般在题目中，我们一般<strong>向下向右兼并</strong>。即编号为<code>i*n+j</code>的点与<strong>符合要求</strong>且<strong>编号为<code>i*n+j+n</code>和<code>i*n+j+1</code>的点</strong>连接。<br>具体步骤为：</p>
<ol>
<li>找到编号为<code>0</code>的点，让它与编号为<code>1</code>和编号为<code>3</code>的点连接起来。</li>
<li>找到编号为<code>1</code>的点，让它与编号为<code>4</code>的点连接起来。</li>
<li>找到编号为<code>3</code>的点，让它与编号为<code>4</code>的点连接起来。</li>
</ol>
<p>那么代码则为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m=grid.length;</span><br><span class="line"><span class="keyword">int</span> n=grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">UnionFind uf=<span class="keyword">new</span> UnionFind(m*n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">    <span class="comment">//确定符合要求的点</span></span><br><span class="line">    <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">//编号</span></span><br><span class="line">      <span class="keyword">int</span> idx=i*n+j;</span><br><span class="line">      <span class="comment">//向下向右连接</span></span><br><span class="line">      <span class="keyword">if</span>(i+<span class="number">1</span>&lt;m&amp;&amp;grid[i+<span class="number">1</span>][j]==<span class="number">1</span>)</span><br><span class="line">        uf.union(idx,idx+n);</span><br><span class="line">      <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n&amp;&amp;grid[i][j+<span class="number">1</span>]==<span class="number">1</span>)</span><br><span class="line">        uf.union(idx,idx+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在许多二维数组使用并查集的情况下，都是<strong>向下向右兼并</strong>。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>注意题目中的数组是字符型数组，思路就仿照上面即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">    <span class="comment">//连通分量的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//x连接的结点为parent[x]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">//对应的根结点的连通分量的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        count=n;</span><br><span class="line">        parent=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">            rank[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*找寻x的根节点*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x!=parent[x])</span><br><span class="line">            x=parent[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*检查p和q是否连接*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*将p和q连接在一起*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP=find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ=find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP==rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[rootP]&lt;rank[rootQ])&#123;</span><br><span class="line">            parent[rootP]=rootQ;</span><br><span class="line">            rank[rootQ]+=rank[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootQ]=rootP;</span><br><span class="line">            rank[rootP]+=rank[rootQ];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*返回连通分量的个数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(grid.length==<span class="number">0</span>||grid[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> m=grid.length;</span><br><span class="line">      <span class="keyword">int</span> n=grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">      UnionFind uf=<span class="keyword">new</span> UnionFind(m*n);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">          <span class="comment">//确定符合要求的点</span></span><br><span class="line">          <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//编号</span></span><br><span class="line">            <span class="keyword">int</span> idx=i*n+j;</span><br><span class="line">            <span class="comment">//向下向右连接</span></span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;m&amp;&amp;grid[i+<span class="number">1</span>][j]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">              uf.union(idx,idx+n);</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n&amp;&amp;grid[i][j+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">              uf.union(idx,idx+<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//返回连通分量的数量</span></span><br><span class="line">      <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上题目的核心思路都是一样的，不同的是第二第三题都是字符串，第四题则是二维数组，那么得想办法先进行编号，然后再使用并查集，就会变得十分简单。</p>
]]></content>
      <categories>
        <category>UnionFind</category>
      </categories>
      <tags>
        <tag>UnionFind</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集模板</title>
    <url>/2021/02/16/UnionFind/UnionFindTemplate/</url>
    <content><![CDATA[<h2 id="并查集解决的问题"><a href="#并查集解决的问题" class="headerlink" title="并查集解决的问题"></a>并查集解决的问题</h2><ul>
<li>p与q是否连接</li>
<li>图中连通分量的数量</li>
</ul>
<h2 id="并查集的具体实现"><a href="#并查集的具体实现" class="headerlink" title="并查集的具体实现"></a>并查集的具体实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">    <span class="comment">//连通分量的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//x连接的结点为parent[x]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">//对应的根结点的连通分量的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        count=n;</span><br><span class="line">        parent=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">            rank[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*找寻x的根节点*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x!=parent[x])</span><br><span class="line">            x=parent[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*检查p和q是否连接*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*将p和q连接在一起*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP=find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ=find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP==rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[rootP]&lt;rank[rootQ])&#123;</span><br><span class="line">            parent[rootP]=rootQ;</span><br><span class="line">            rank[rootQ]+=rank[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootQ]=rootP;</span><br><span class="line">            rank[rootP]+=rank[rootQ];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*返回连通分量的个数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote>
<p>《算法》(第四版) P136-P149</p>
</blockquote>
]]></content>
      <categories>
        <category>UnionFind</category>
      </categories>
      <tags>
        <tag>UnionFind</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode快捷指令</title>
    <url>/2021/02/21/wiki/vscode/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>选中当前行</td>
<td>ctrl+”L”</td>
</tr>
<tr>
<td>按单词进行选中</td>
<td>Ctrl + Shift + ←/→</td>
</tr>
<tr>
<td>添加/关闭行注释</td>
<td>ctrl+”/“</td>
</tr>
<tr>
<td>添加/关闭区块注释</td>
<td>shift+alt+”A”</td>
</tr>
<tr>
<td>撤销</td>
<td>ctrl+”z”</td>
</tr>
</tbody></table>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>整体向左缩进</td>
<td>ctrl+”[“</td>
</tr>
<tr>
<td>整体向右缩进</td>
<td>ctrl+”]”</td>
</tr>
<tr>
<td>向上移动一行</td>
<td>alt+↑</td>
</tr>
<tr>
<td>向下移动一行</td>
<td>alt+↓</td>
</tr>
<tr>
<td>向上复制一行</td>
<td>shift+alt+↑</td>
</tr>
<tr>
<td>向下复制一行</td>
<td>shift+alt+↓</td>
</tr>
<tr>
<td>删除行</td>
<td>ctrl+alt+”K”</td>
</tr>
</tbody></table>
<h2 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h2><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>移动到行首</td>
<td>Home</td>
</tr>
<tr>
<td>移动到行尾</td>
<td>End</td>
</tr>
<tr>
<td>移动到文件首</td>
<td>ctrl+Home</td>
</tr>
<tr>
<td>移动到文件尾</td>
<td>ctrl+End</td>
</tr>
<tr>
<td>按单词移动光标</td>
<td>Ctrl + ←/→</td>
</tr>
</tbody></table>
<h2 id="查询与替换"><a href="#查询与替换" class="headerlink" title="查询与替换"></a>查询与替换</h2><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>查询</td>
<td>ctrl+”F”</td>
</tr>
<tr>
<td>替换</td>
<td>ctrl+”H”</td>
</tr>
<tr>
<td>查询下一个/上一个</td>
<td>F3/Shift+F3</td>
</tr>
</tbody></table>
<p>先更新这些……</p>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>快捷指令</tag>
      </tags>
  </entry>
  <entry>
    <title>windows快捷指令</title>
    <url>/2021/02/17/wiki/windows/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>快速打开windows搜索</td>
<td>win+”Q”</td>
</tr>
<tr>
<td>窗口最小化</td>
<td>win+↓</td>
</tr>
<tr>
<td>窗口最大化</td>
<td>win+↑</td>
</tr>
<tr>
<td>标签页页进行切换</td>
<td>ctrl+Tab</td>
</tr>
<tr>
<td>关闭当前标签页</td>
<td>ctrl+”W”</td>
</tr>
<tr>
<td>重新打开刚刚关闭的页面</td>
<td>ctrl+shift+”T”</td>
</tr>
<tr>
<td>打开新的标签页</td>
<td>ctrl+”T”</td>
</tr>
<tr>
<td>查看浏览器记录</td>
<td>ctrl+”H”</td>
</tr>
<tr>
<td>查找关键字</td>
<td>ctrl+”F”</td>
</tr>
<tr>
<td>到达网址栏</td>
<td>ctrl+”L”</td>
</tr>
<tr>
<td>查看历史记录</td>
<td>ctrl+”H”</td>
</tr>
<tr>
<td>新增浏览器视窗</td>
<td>ctrl+”N”</td>
</tr>
<tr>
<td>切换任务窗口</td>
<td>Alt+Tab</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>快捷指令</tag>
        <tag>windows</tag>
      </tags>
  </entry>
</search>
