<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>vscode快捷指令</title>
    <url>/2021/02/21/wiki/vscode/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>选中当前行</td>
<td>ctrl+”L”</td>
</tr>
<tr>
<td>按单词进行选中</td>
<td>Ctrl + Shift + ←/→</td>
</tr>
<tr>
<td>添加/关闭行注释</td>
<td>ctrl+”/“</td>
</tr>
<tr>
<td>添加/关闭区块注释</td>
<td>shift+alt+”A”</td>
</tr>
<tr>
<td>撤销</td>
<td>ctrl+”z”</td>
</tr>
</tbody></table>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>整体向左缩进</td>
<td>ctrl+”[“</td>
</tr>
<tr>
<td>整体向右缩进</td>
<td>ctrl+”]”</td>
</tr>
<tr>
<td>向上移动一行</td>
<td>alt+↑</td>
</tr>
<tr>
<td>向下移动一行</td>
<td>alt+↓</td>
</tr>
<tr>
<td>向上复制一行</td>
<td>shift+alt+↑</td>
</tr>
<tr>
<td>向下复制一行</td>
<td>shift+alt+↓</td>
</tr>
<tr>
<td>删除行</td>
<td>ctrl+alt+”K”</td>
</tr>
</tbody></table>
<h2 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h2><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>移动到行首</td>
<td>Home</td>
</tr>
<tr>
<td>移动到行尾</td>
<td>End</td>
</tr>
<tr>
<td>移动到文件首</td>
<td>ctrl+Home</td>
</tr>
<tr>
<td>移动到文件尾</td>
<td>ctrl+End</td>
</tr>
<tr>
<td>按单词移动光标</td>
<td>Ctrl + ←/→</td>
</tr>
</tbody></table>
<h2 id="查询与替换"><a href="#查询与替换" class="headerlink" title="查询与替换"></a>查询与替换</h2><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>查询</td>
<td>ctrl+”F”</td>
</tr>
<tr>
<td>替换</td>
<td>ctrl+”H”</td>
</tr>
<tr>
<td>查询下一个/上一个</td>
<td>F3/Shift+F3</td>
</tr>
</tbody></table>
<p>先更新这些……</p>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>快捷指令</tag>
      </tags>
  </entry>
  <entry>
    <title>windows快捷指令</title>
    <url>/2021/02/17/wiki/windows/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>快速打开windows搜索</td>
<td>win+”Q”</td>
</tr>
<tr>
<td>窗口最小化</td>
<td>win+↓</td>
</tr>
<tr>
<td>窗口最大化</td>
<td>win+↑</td>
</tr>
<tr>
<td>标签页页进行切换</td>
<td>ctrl+Tab</td>
</tr>
<tr>
<td>关闭当前标签页</td>
<td>ctrl+”W”</td>
</tr>
<tr>
<td>重新打开刚刚关闭的页面</td>
<td>ctrl+shift+”T”</td>
</tr>
<tr>
<td>打开新的标签页</td>
<td>ctrl+”T”</td>
</tr>
<tr>
<td>查看浏览器记录</td>
<td>ctrl+”H”</td>
</tr>
<tr>
<td>查找关键字</td>
<td>ctrl+”F”</td>
</tr>
<tr>
<td>到达网址栏</td>
<td>ctrl+”L”</td>
</tr>
<tr>
<td>查看历史记录</td>
<td>ctrl+”H”</td>
</tr>
<tr>
<td>新增浏览器视窗</td>
<td>ctrl+”N”</td>
</tr>
<tr>
<td>切换任务窗口</td>
<td>Alt+Tab</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>快捷指令</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组中使用并查集</title>
    <url>/2021/02/19/UnionFind/UnionFind2nd/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在很多题目中，也有二维数组需要使用并查集的情况。如，要把下图中值为1的点全部连起来，每个点只能与水平相邻和竖直相邻的点连接：</p>
<div align=center>
  <img src="https://gitee.com/liang_haonan/blogimg/raw/master/img/2ndarray.png"/>
</div>

<h3 id="编号"><a href="#编号" class="headerlink" title="编号"></a>编号</h3><p>解决这个问题主要首先就是编号。二维数组中的编号可以采用如下方式编号：</p>
<p>*<em>令(假设二维数组为<code>grid</code>)<code>m=grid.length, n=grid[0].length</code>，点<code>(i,j)</code>的编号就为<code>i*n+j</code>，则总共的点的数量为m</em>n**<br>如下图所示：</p>
<div align=center>
  <img src="https://gitee.com/liang_haonan/blogimg/raw/master/img/2ndarray2.png"/>
</div>

<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>然后就是连接，按照题目要求，<strong>把值为1的点全部连接起来</strong>，<strong>每个点只能与水平相邻和数值相邻的点连接</strong>。<br>描述地更加具体就是:</p>
<ol>
<li>找到编号为<code>0</code>的点，让它与编号为<code>1</code>和编号为<code>3</code>的点连接起来。</li>
<li>找到编号为<code>1</code>的点，让它与编号为<code>0</code>和编号为<code>4</code>的点连接起来。</li>
<li>找到编号为<code>3</code>的点，让它与编号为<code>0</code>和编号为<code>4</code>的点连接起来。</li>
<li>找到编号为<code>4</code>的点，让它与编号为<code>1</code>和编号为<code>3</code>的点连接起来。</li>
</ol>
<p>虽然步骤是这样，但是还是上述过程可以看到有很多重复项，所以一般在题目中，我们一般<strong>向下向右兼并</strong>。即编号为<code>i*n+j</code>的点与<strong>符合要求</strong>且<strong>编号为<code>i*n+j+n</code>和<code>i*n+j+1</code>的点</strong>连接。<br>具体步骤为：</p>
<ol>
<li>找到编号为<code>0</code>的点，让它与编号为<code>1</code>和编号为<code>3</code>的点连接起来。</li>
<li>找到编号为<code>1</code>的点，让编号为<code>4</code>的点连接起来。</li>
<li>找到编号为<code>3</code>的点，让它与编号为<code>0</code>和编号为<code>4</code>的点连接起来。</li>
</ol>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>综上所述，实现步骤如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m=grid.length;</span><br><span class="line"><span class="keyword">int</span> n=grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">UnionFind uf=<span class="keyword">new</span> UnionFind(m*n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">    <span class="comment">//确定符合要求的点</span></span><br><span class="line">    <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">//编号</span></span><br><span class="line">      <span class="keyword">int</span> idx=i*n+j;</span><br><span class="line">      <span class="comment">//向下向右连接</span></span><br><span class="line">      <span class="keyword">if</span>(i+<span class="number">1</span>&lt;m&amp;&amp;grid[i+<span class="number">1</span>][j]==<span class="number">1</span>)</span><br><span class="line">        uf.union(idx,idx+n);</span><br><span class="line">      <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n&amp;&amp;grid[i][j+<span class="number">1</span>]==<span class="number">1</span>)</span><br><span class="line">        uf.union(idx,idx+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LeetCode200-岛屿数量"><a href="#LeetCode200-岛屿数量" class="headerlink" title="LeetCode200.岛屿数量"></a>LeetCode200.岛屿数量</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://gitee.com/liang_haonan/blogimg/raw/master/img/uf2.PNG"></p>
<p><a href="https://leetcode-cn.com/problems/number-of-islands/"><em>点此链接跳转题目</em></a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按照上述实现步骤即可，只不过注意这里数组为字符串数组。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">    <span class="comment">//连通分量的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//x连接的结点为parent[x]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">//对应的根结点的连通分量的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        count=n;</span><br><span class="line">        parent=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">            rank[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*找寻x的根节点*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x!=parent[x])</span><br><span class="line">            x=parent[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*检查p和q是否连接*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*将p和q连接在一起*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP=find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ=find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP==rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[rootP]&lt;rank[rootQ])&#123;</span><br><span class="line">            parent[rootP]=rootQ;</span><br><span class="line">            rank[rootQ]+=rank[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootQ]=rootP;</span><br><span class="line">            rank[rootP]+=rank[rootQ];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*返回连通分量的个数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(grid.length==<span class="number">0</span>||grid[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> m=grid.length;</span><br><span class="line">      <span class="keyword">int</span> n=grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">      UnionFind uf=<span class="keyword">new</span> UnionFind(m*n);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">          <span class="comment">//确定符合要求的点</span></span><br><span class="line">          <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//编号</span></span><br><span class="line">            <span class="keyword">int</span> idx=i*n+j;</span><br><span class="line">            <span class="comment">//向下向右连接</span></span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;m&amp;&amp;grid[i+<span class="number">1</span>][j]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">              uf.union(idx,idx+n);</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n&amp;&amp;grid[i][j+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">              uf.union(idx,idx+<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//返回连通分量的数量</span></span><br><span class="line">      <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以在考虑连通分量的数量的时候，大部分情况下都会优先选择并查集，但是在如何编号这方面也要下功夫研究一下。</p>
]]></content>
      <categories>
        <category>UnionFind</category>
      </categories>
      <tags>
        <tag>UnionFind</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集基本使用</title>
    <url>/2021/02/18/UnionFind/UnionFindBasis/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>对于以下的题目，便是并查集模板的基本用法。</p>
<h2 id="Leetcode547-省份数量"><a href="#Leetcode547-省份数量" class="headerlink" title="Leetcode547.省份数量"></a>Leetcode547.省份数量</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://gitee.com/liang_haonan/blogimg/raw/master/img/ufb1.PNG"></p>
<p><a href="https://leetcode-cn.com/problems/number-of-provinces/"><em>点此链接跳转题目</em></a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接套模板，然后得出连通分量的数量即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">  <span class="comment">//记录连通分量的个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">  <span class="comment">//节点x指向的节点是parent[x]</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[]parent;</span><br><span class="line">  <span class="comment">/*构造函数，最开始每个节点指向自己*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count=n;</span><br><span class="line">    parent=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">      parent[i]=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*将节点p与q连接*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(connect(p,q))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> rootP=find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ=find(q);</span><br><span class="line">    parent[rootP]=rootQ;</span><br><span class="line">    count--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*找到x的根节点*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(parent[x]!=x)</span><br><span class="line">      x=parent[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*查看p与q是否连接*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP=find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ=find(q);</span><br><span class="line">    <span class="keyword">return</span> rootP==rootQ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*查看连通分量的个数*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">number</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> N=M.length;</span><br><span class="line">      UF uf=<span class="keyword">new</span> UF(N);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(M[i][j]==<span class="number">1</span>)</span><br><span class="line">            uf.union(i,j);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> uf.number();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode839-相似的字符串数组"><a href="#Leetcode839-相似的字符串数组" class="headerlink" title="Leetcode839.相似的字符串数组"></a>Leetcode839.相似的字符串数组</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://gitee.com/liang_haonan/blogimg/raw/master/img/ufb3.PNG"></p>
<p><a href="https://leetcode-cn.com/problems/similar-string-groups/"><em>点此链接跳转题目</em></a></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>跟上题一样，每个字符串可以看成一个点，若两个字符串相似便可以看成两个点连接，最后判断连通分量的个数即可。</p>
<p>判断相似的方法，由于是字母异位词(所有单词字母种类数量相同位置不同)，所以只要对应两个位置及以下字母不相同即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSimilar</span><span class="params">(String a,String b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n=a.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.charAt(i)!=b.charAt(i))</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt&lt;=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        count=n;</span><br><span class="line">        parent=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">            rank[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x!=parent[x])</span><br><span class="line">            x=parent[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP=find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ=find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP==rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[rootP]&lt;rank[rootQ])&#123;</span><br><span class="line">            parent[rootP]=rootQ;</span><br><span class="line">            rank[rootQ]+=rank[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootQ]=rootP;</span><br><span class="line">            rank[rootP]+=rank[rootQ];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSimilar</span><span class="params">(String a,String b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = a.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.charAt(i) != b.charAt(i)) cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=strs.length;</span><br><span class="line">        UnionFind uf=<span class="keyword">new</span> UnionFind(len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isSimilar(strs[i],strs[j]))</span><br><span class="line">                    uf.union(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode737-句子相似性II"><a href="#Leetcode737-句子相似性II" class="headerlink" title="Leetcode737.句子相似性II"></a>Leetcode737.句子相似性II</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://gitee.com/liang_haonan/blogimg/raw/master/img/ufb2.PNG"></p>
<p><a href="https://leetcode-cn.com/problems/sentence-similarity-ii/"><em>点此链接跳转题目</em></a></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>根据上面的题目一样，将每个字符串当作一个点，如果两个字符串相似那就将对应的点连接到一起。那么如何让每个字符串对应相应的点呢？当然是对<code>pairs</code>每个字符串进行编号。</p>
<p><strong>编号代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用hashMap使每个字符串有对应的编号</span></span><br><span class="line">Map&lt;String,Integer&gt;hashMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//从0开始编号</span></span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(List&lt;String&gt;pair:pairs)&#123;</span><br><span class="line">    String a=pair.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//如果已经有编号就放弃</span></span><br><span class="line">    <span class="keyword">if</span>(!hashMap.containsKey(a))&#123;</span><br><span class="line">        hashMap.put(a,index);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    String b=pair.get(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!hashMap.containsKey(b))&#123;</span><br><span class="line">        hashMap.put(b,index);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后只要看<code>words1</code>和<code>words2</code>对应位置的字符串是否相似，即对应位置字符串各自对应的编号是否在同一连通分量里面即可，如果有一个位置不在，那就直接<code>false</code>。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">int</span>[] rank;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        parent=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">            rank[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x!=parent[x])</span><br><span class="line">            x=parent[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP=find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ=find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP==rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[rootP]&lt;rank[rootQ])&#123;</span><br><span class="line">            parent[rootP]=rootQ;</span><br><span class="line">            rank[rootQ]+=rank[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootQ]=rootP;</span><br><span class="line">            rank[rootP]+=rank[rootQ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areSentencesSimilarTwo</span><span class="params">(String[] words1, String[] words2, List&lt;List&lt;String&gt;&gt; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words1.length!=words2.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map&lt;String,Integer&gt;hashMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt;pair:pairs)&#123;</span><br><span class="line">            String a=pair.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(!hashMap.containsKey(a))&#123;</span><br><span class="line">                hashMap.put(a,index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            String b=pair.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!hashMap.containsKey(b))&#123;</span><br><span class="line">                hashMap.put(b,index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        UnionFind unionfind=<span class="keyword">new</span> UnionFind(index);</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt;pair:pairs)&#123;</span><br><span class="line">            String a=pair.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> index0=hashMap.get(a);</span><br><span class="line">            String b=pair.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> index1=hashMap.get(b);</span><br><span class="line">            unionfind.union(index0,index1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len=words1.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            String word1=words1[i]; Integer index0=hashMap.get(word1);</span><br><span class="line">            String word2=words2[i]; Integer index1=hashMap.get(word2);</span><br><span class="line">            <span class="keyword">if</span>(word1.equals(word2))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(index0==<span class="keyword">null</span>||index1==<span class="keyword">null</span>||!unionfind.connected(index0,index1))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上题目的核心思路都是一样的，不同的是第二第三题都是字符串，那么得想办法先进行编号，然后再使用并查集，就会变得十分简单。</p>
]]></content>
      <categories>
        <category>UnionFind</category>
      </categories>
      <tags>
        <tag>UnionFind</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集模板</title>
    <url>/2021/02/16/UnionFind/UnionFindTemplate/</url>
    <content><![CDATA[<h2 id="并查集解决的问题"><a href="#并查集解决的问题" class="headerlink" title="并查集解决的问题"></a>并查集解决的问题</h2><ul>
<li>p与q是否连接</li>
<li>图中连通分量的数量</li>
</ul>
<h2 id="并查集的具体实现"><a href="#并查集的具体实现" class="headerlink" title="并查集的具体实现"></a>并查集的具体实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">    <span class="comment">//连通分量的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//x连接的结点为parent[x]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">//对应的根结点的连通分量的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        count=n;</span><br><span class="line">        parent=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">            rank[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*找寻x的根节点*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x!=parent[x])</span><br><span class="line">            x=parent[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*检查p和q是否连接*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*将p和q连接在一起*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP=find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ=find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP==rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[rootP]&lt;rank[rootQ])&#123;</span><br><span class="line">            parent[rootP]=rootQ;</span><br><span class="line">            rank[rootQ]+=rank[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootQ]=rootP;</span><br><span class="line">            rank[rootP]+=rank[rootQ];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*返回连通分量的个数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote>
<p>《算法》(第四版) P136-P149</p>
</blockquote>
]]></content>
      <categories>
        <category>UnionFind</category>
      </categories>
      <tags>
        <tag>UnionFind</tag>
        <tag>模板</tag>
      </tags>
  </entry>
</search>
